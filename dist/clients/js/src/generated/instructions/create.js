/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */
import { combineCodec, getStructDecoder, getStructEncoder, getU8Decoder, getU8Encoder, transformEncoder, } from '@solana/kit';
import { AQUA_SWAP_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory } from '../shared';
import { getCreateDataDecoder, getCreateDataEncoder, } from '../types';
export const CREATE_DISCRIMINATOR = 0;
export function getCreateDiscriminatorBytes() {
    return getU8Encoder().encode(CREATE_DISCRIMINATOR);
}
export function getCreateInstructionDataEncoder() {
    return transformEncoder(getStructEncoder([
        ['discriminator', getU8Encoder()],
        ['createData', getCreateDataEncoder()],
    ]), (value) => ({ ...value, discriminator: CREATE_DISCRIMINATOR }));
}
export function getCreateInstructionDataDecoder() {
    return getStructDecoder([
        ['discriminator', getU8Decoder()],
        ['createData', getCreateDataDecoder()],
    ]);
}
export function getCreateInstructionDataCodec() {
    return combineCodec(getCreateInstructionDataEncoder(), getCreateInstructionDataDecoder());
}
export function getCreateInstruction(input, config) {
    // Program address.
    const programAddress = config?.programAddress ?? AQUA_SWAP_PROGRAM_ADDRESS;
    // Original accounts.
    const originalAccounts = {
        ownerAcc: { value: input.ownerAcc ?? null, isWritable: true },
        swapAcc: { value: input.swapAcc ?? null, isWritable: true },
        vaultBaseAcc: { value: input.vaultBaseAcc ?? null, isWritable: false },
        vaultQuoteAcc: { value: input.vaultQuoteAcc ?? null, isWritable: false },
        systemProgram: { value: input.systemProgram ?? null, isWritable: false },
        rent: { value: input.rent ?? null, isWritable: false },
    };
    const accounts = originalAccounts;
    // Original args.
    const args = { ...input };
    // Resolve default values.
    if (!accounts.systemProgram.value) {
        accounts.systemProgram.value =
            '11111111111111111111111111111111';
    }
    if (!accounts.rent.value) {
        accounts.rent.value =
            'SysvarRent111111111111111111111111111111111';
    }
    const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    return Object.freeze({
        accounts: [
            getAccountMeta(accounts.ownerAcc),
            getAccountMeta(accounts.swapAcc),
            getAccountMeta(accounts.vaultBaseAcc),
            getAccountMeta(accounts.vaultQuoteAcc),
            getAccountMeta(accounts.systemProgram),
            getAccountMeta(accounts.rent),
        ],
        data: getCreateInstructionDataEncoder().encode(args),
        programAddress,
    });
}
export function parseCreateInstruction(instruction) {
    if (instruction.accounts.length < 6) {
        // TODO: Coded error.
        throw new Error('Not enough accounts');
    }
    let accountIndex = 0;
    const getNextAccount = () => {
        const accountMeta = instruction.accounts[accountIndex];
        accountIndex += 1;
        return accountMeta;
    };
    return {
        programAddress: instruction.programAddress,
        accounts: {
            ownerAcc: getNextAccount(),
            swapAcc: getNextAccount(),
            vaultBaseAcc: getNextAccount(),
            vaultQuoteAcc: getNextAccount(),
            systemProgram: getNextAccount(),
            rent: getNextAccount(),
        },
        data: getCreateInstructionDataDecoder().decode(instruction.data),
    };
}
